// Code generated by goa v3.14.1, DO NOT EDIT.
//
// chat_messages gRPC client encoders and decoders
//
// Command:
// $ goa gen apisvr/design -o ./services

package client

import (
	chatmessages "apisvr/services/gen/chat_messages"
	chatmessagesviews "apisvr/services/gen/chat_messages/views"
	chat_messagespb "apisvr/services/gen/grpc/chat_messages/pb"
	"context"

	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildListFunc builds the remote method to invoke for "chat_messages" service
// "list" endpoint.
func BuildListFunc(grpccli chat_messagespb.ChatMessagesClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.List(ctx, reqpb.(*chat_messagespb.ListRequest), opts...)
		}
		return grpccli.List(ctx, &chat_messagespb.ListRequest{}, opts...)
	}
}

// EncodeListRequest encodes requests sent to chat_messages list endpoint.
func EncodeListRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*chatmessages.ListPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("chat_messages", "list", "*chatmessages.ListPayload", v)
	}
	(*md).Append("authorization", payload.IDToken)
	return NewProtoListRequest(payload), nil
}

// DecodeListResponse decodes responses from the chat_messages list endpoint.
func DecodeListResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*chat_messagespb.ListResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("chat_messages", "list", "*chat_messagespb.ListResponse", v)
	}
	res := NewListResult(message)
	vres := &chatmessagesviews.ChatMessageList{Projected: res, View: view}
	if err := chatmessagesviews.ValidateChatMessageList(vres); err != nil {
		return nil, err
	}
	return chatmessages.NewChatMessageList(vres), nil
}

// BuildShowFunc builds the remote method to invoke for "chat_messages" service
// "show" endpoint.
func BuildShowFunc(grpccli chat_messagespb.ChatMessagesClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Show(ctx, reqpb.(*chat_messagespb.ShowRequest), opts...)
		}
		return grpccli.Show(ctx, &chat_messagespb.ShowRequest{}, opts...)
	}
}

// EncodeShowRequest encodes requests sent to chat_messages show endpoint.
func EncodeShowRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*chatmessages.ShowPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("chat_messages", "show", "*chatmessages.ShowPayload", v)
	}
	(*md).Append("authorization", payload.IDToken)
	return NewProtoShowRequest(payload), nil
}

// DecodeShowResponse decodes responses from the chat_messages show endpoint.
func DecodeShowResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*chat_messagespb.ShowResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("chat_messages", "show", "*chat_messagespb.ShowResponse", v)
	}
	res := NewShowResult(message)
	vres := &chatmessagesviews.ChatMessage{Projected: res, View: view}
	if err := chatmessagesviews.ValidateChatMessage(vres); err != nil {
		return nil, err
	}
	return chatmessages.NewChatMessage(vres), nil
}

// BuildCreateFunc builds the remote method to invoke for "chat_messages"
// service "create" endpoint.
func BuildCreateFunc(grpccli chat_messagespb.ChatMessagesClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Create(ctx, reqpb.(*chat_messagespb.CreateRequest), opts...)
		}
		return grpccli.Create(ctx, &chat_messagespb.CreateRequest{}, opts...)
	}
}

// EncodeCreateRequest encodes requests sent to chat_messages create endpoint.
func EncodeCreateRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*chatmessages.ChatMessageCreatePayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("chat_messages", "create", "*chatmessages.ChatMessageCreatePayload", v)
	}
	(*md).Append("authorization", payload.IDToken)
	return NewProtoCreateRequest(payload), nil
}

// DecodeCreateResponse decodes responses from the chat_messages create
// endpoint.
func DecodeCreateResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*chat_messagespb.CreateResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("chat_messages", "create", "*chat_messagespb.CreateResponse", v)
	}
	res := NewCreateResult(message)
	vres := &chatmessagesviews.ChatMessage{Projected: res, View: view}
	if err := chatmessagesviews.ValidateChatMessage(vres); err != nil {
		return nil, err
	}
	return chatmessages.NewChatMessage(vres), nil
}

// BuildUpdateFunc builds the remote method to invoke for "chat_messages"
// service "update" endpoint.
func BuildUpdateFunc(grpccli chat_messagespb.ChatMessagesClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Update(ctx, reqpb.(*chat_messagespb.UpdateRequest), opts...)
		}
		return grpccli.Update(ctx, &chat_messagespb.UpdateRequest{}, opts...)
	}
}

// EncodeUpdateRequest encodes requests sent to chat_messages update endpoint.
func EncodeUpdateRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*chatmessages.ChatMessageUpdatePayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("chat_messages", "update", "*chatmessages.ChatMessageUpdatePayload", v)
	}
	(*md).Append("authorization", payload.IDToken)
	return NewProtoUpdateRequest(payload), nil
}

// DecodeUpdateResponse decodes responses from the chat_messages update
// endpoint.
func DecodeUpdateResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*chat_messagespb.UpdateResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("chat_messages", "update", "*chat_messagespb.UpdateResponse", v)
	}
	res := NewUpdateResult(message)
	vres := &chatmessagesviews.ChatMessage{Projected: res, View: view}
	if err := chatmessagesviews.ValidateChatMessage(vres); err != nil {
		return nil, err
	}
	return chatmessages.NewChatMessage(vres), nil
}

// BuildDeleteFunc builds the remote method to invoke for "chat_messages"
// service "delete" endpoint.
func BuildDeleteFunc(grpccli chat_messagespb.ChatMessagesClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Delete(ctx, reqpb.(*chat_messagespb.DeleteRequest), opts...)
		}
		return grpccli.Delete(ctx, &chat_messagespb.DeleteRequest{}, opts...)
	}
}

// EncodeDeleteRequest encodes requests sent to chat_messages delete endpoint.
func EncodeDeleteRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*chatmessages.DeletePayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("chat_messages", "delete", "*chatmessages.DeletePayload", v)
	}
	(*md).Append("authorization", payload.IDToken)
	return NewProtoDeleteRequest(payload), nil
}

// DecodeDeleteResponse decodes responses from the chat_messages delete
// endpoint.
func DecodeDeleteResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*chat_messagespb.DeleteResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("chat_messages", "delete", "*chat_messagespb.DeleteResponse", v)
	}
	res := NewDeleteResult(message)
	vres := &chatmessagesviews.ChatMessage{Projected: res, View: view}
	if err := chatmessagesviews.ValidateChatMessage(vres); err != nil {
		return nil, err
	}
	return chatmessages.NewChatMessage(vres), nil
}
