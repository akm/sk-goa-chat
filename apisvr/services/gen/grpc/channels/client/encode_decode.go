// Code generated by goa v3.14.1, DO NOT EDIT.
//
// channels gRPC client encoders and decoders
//
// Command:
// $ goa gen apisvr/design -o ./services

package client

import (
	channels "apisvr/services/gen/channels"
	channelsviews "apisvr/services/gen/channels/views"
	channelspb "apisvr/services/gen/grpc/channels/pb"
	"context"

	goagrpc "goa.design/goa/v3/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/metadata"
)

// BuildListFunc builds the remote method to invoke for "channels" service
// "list" endpoint.
func BuildListFunc(grpccli channelspb.ChannelsClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.List(ctx, reqpb.(*channelspb.ListRequest), opts...)
		}
		return grpccli.List(ctx, &channelspb.ListRequest{}, opts...)
	}
}

// EncodeListRequest encodes requests sent to channels list endpoint.
func EncodeListRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*channels.ListPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("channels", "list", "*channels.ListPayload", v)
	}
	(*md).Append("authorization", payload.SessionID)
	return NewProtoListRequest(), nil
}

// DecodeListResponse decodes responses from the channels list endpoint.
func DecodeListResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*channelspb.ListResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("channels", "list", "*channelspb.ListResponse", v)
	}
	res := NewListResult(message)
	vres := &channelsviews.ChannelList{Projected: res, View: view}
	if err := channelsviews.ValidateChannelList(vres); err != nil {
		return nil, err
	}
	return channels.NewChannelList(vres), nil
}

// BuildShowFunc builds the remote method to invoke for "channels" service
// "show" endpoint.
func BuildShowFunc(grpccli channelspb.ChannelsClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Show(ctx, reqpb.(*channelspb.ShowRequest), opts...)
		}
		return grpccli.Show(ctx, &channelspb.ShowRequest{}, opts...)
	}
}

// EncodeShowRequest encodes requests sent to channels show endpoint.
func EncodeShowRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*channels.ShowPayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("channels", "show", "*channels.ShowPayload", v)
	}
	(*md).Append("authorization", payload.SessionID)
	return NewProtoShowRequest(payload), nil
}

// DecodeShowResponse decodes responses from the channels show endpoint.
func DecodeShowResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*channelspb.ShowResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("channels", "show", "*channelspb.ShowResponse", v)
	}
	res := NewShowResult(message)
	vres := &channelsviews.Channel{Projected: res, View: view}
	if err := channelsviews.ValidateChannel(vres); err != nil {
		return nil, err
	}
	return channels.NewChannel(vres), nil
}

// BuildCreateFunc builds the remote method to invoke for "channels" service
// "create" endpoint.
func BuildCreateFunc(grpccli channelspb.ChannelsClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Create(ctx, reqpb.(*channelspb.CreateRequest), opts...)
		}
		return grpccli.Create(ctx, &channelspb.CreateRequest{}, opts...)
	}
}

// EncodeCreateRequest encodes requests sent to channels create endpoint.
func EncodeCreateRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*channels.ChannelCreatePayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("channels", "create", "*channels.ChannelCreatePayload", v)
	}
	(*md).Append("authorization", payload.SessionID)
	return NewProtoCreateRequest(payload), nil
}

// DecodeCreateResponse decodes responses from the channels create endpoint.
func DecodeCreateResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*channelspb.CreateResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("channels", "create", "*channelspb.CreateResponse", v)
	}
	res := NewCreateResult(message)
	vres := &channelsviews.Channel{Projected: res, View: view}
	if err := channelsviews.ValidateChannel(vres); err != nil {
		return nil, err
	}
	return channels.NewChannel(vres), nil
}

// BuildUpdateFunc builds the remote method to invoke for "channels" service
// "update" endpoint.
func BuildUpdateFunc(grpccli channelspb.ChannelsClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Update(ctx, reqpb.(*channelspb.UpdateRequest), opts...)
		}
		return grpccli.Update(ctx, &channelspb.UpdateRequest{}, opts...)
	}
}

// EncodeUpdateRequest encodes requests sent to channels update endpoint.
func EncodeUpdateRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*channels.ChannelUpdatePayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("channels", "update", "*channels.ChannelUpdatePayload", v)
	}
	(*md).Append("authorization", payload.SessionID)
	return NewProtoUpdateRequest(payload), nil
}

// DecodeUpdateResponse decodes responses from the channels update endpoint.
func DecodeUpdateResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*channelspb.UpdateResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("channels", "update", "*channelspb.UpdateResponse", v)
	}
	res := NewUpdateResult(message)
	vres := &channelsviews.Channel{Projected: res, View: view}
	if err := channelsviews.ValidateChannel(vres); err != nil {
		return nil, err
	}
	return channels.NewChannel(vres), nil
}

// BuildDeleteFunc builds the remote method to invoke for "channels" service
// "delete" endpoint.
func BuildDeleteFunc(grpccli channelspb.ChannelsClient, cliopts ...grpc.CallOption) goagrpc.RemoteFunc {
	return func(ctx context.Context, reqpb any, opts ...grpc.CallOption) (any, error) {
		for _, opt := range cliopts {
			opts = append(opts, opt)
		}
		if reqpb != nil {
			return grpccli.Delete(ctx, reqpb.(*channelspb.DeleteRequest), opts...)
		}
		return grpccli.Delete(ctx, &channelspb.DeleteRequest{}, opts...)
	}
}

// EncodeDeleteRequest encodes requests sent to channels delete endpoint.
func EncodeDeleteRequest(ctx context.Context, v any, md *metadata.MD) (any, error) {
	payload, ok := v.(*channels.DeletePayload)
	if !ok {
		return nil, goagrpc.ErrInvalidType("channels", "delete", "*channels.DeletePayload", v)
	}
	(*md).Append("authorization", payload.SessionID)
	return NewProtoDeleteRequest(payload), nil
}

// DecodeDeleteResponse decodes responses from the channels delete endpoint.
func DecodeDeleteResponse(ctx context.Context, v any, hdr, trlr metadata.MD) (any, error) {
	var view string
	{
		if vals := hdr.Get("goa-view"); len(vals) > 0 {
			view = vals[0]
		}
	}
	message, ok := v.(*channelspb.DeleteResponse)
	if !ok {
		return nil, goagrpc.ErrInvalidType("channels", "delete", "*channelspb.DeleteResponse", v)
	}
	res := NewDeleteResult(message)
	vres := &channelsviews.Channel{Projected: res, View: view}
	if err := channelsviews.ValidateChannel(vres); err != nil {
		return nil, err
	}
	return channels.NewChannel(vres), nil
}
